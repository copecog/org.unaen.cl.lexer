;;;; lexer.lisp
;;;;
;;;; Copyright (C) 2017 Christopher H Cope
;;;; All rights reserved.
;;;;
;;;; This software may be modified and distributed under the terms
;;;; of the BSD license.  See the LICENSE file for details.

;;;;   This is intended as a most literal implementation according to the
;;;; mathematical definition of finite automata used by lexers.

;;;;   The plan is to make something that takes a sort of expression mapping
;;;; directly to piece-wise construction of regular expression NFAs (since
;;;; regular expression grammar itself is context-free), and then convert the
;;;; NFA to a DFA, and the DFA to a generated function that can be used as a
;;;; scanner.

;;;;   After I complete this, I want to write a parser for context free
;;;; grammars that couples with this scanner so that I can generate
;;;; scanner/lexer functions for regular expressions and perl-style regular
;;;; expressions.

(in-package #:lexer)

;;; Class Definitions

;;   There are several classes of states across varying classes of finite
;; automata as well as transitional sets of states while functionally mapping
;; from one automaton to another.
;;   This scheme with a preface and iterate allows us to have systematic naming
;; that is still flexible.
(defclass state-names ()
  ((preface :initarg :preface
	    :initform "q_"
	    :reader preface)
   (iterate :initarg :iterate
	    :initform 0
	    :reader iterate))
  (:documentation "Reference to create a series of related states."))

;;   The set Q of states, however named--each state is enumerated by the integer
;; indices of an array.
(defclass Q ()
  ((Q :initarg :Q
      :initform (make-state-vector 1)
      :reader Q
      :documentation "A finite set of states Q.")))

;;   The set Σ of input symbols.  Whatever the input symbols are, they need
;; enumeration--however, we are going to use the built in character encoding in
;; lisp to give us that mapping (signified by a 'cl-utf slot-value).
(defclass Σ ()
  ((Σ :initarg :Σ
      :initform 'cl-utf
      :reader Σ
      :documentation "A finite set of input symbols Σ.")))

;;   A transition function Δ : Q × Σ → P(Q). Using the enumeration from Q we
;; store each state object under an array, and each state contains the
;; transitions on symbols from Σ, which gives us our function map.
(defclass Δ ()
  ((Δ :initarg :Δ
      :initform (make-state-vector 1)
      :reader Δ
      :documentation "A transition function Δ : Q × Σ → P(Q).")))

;;   The initial or starting state of the finite automata. Usually named as
;; q₀ ∈ Q in the mathematical definition.
(defclass q₀ ()
  ((q₀ :initarg :q₀
       :reader q₀
       :documentation "An initial (or start) state q₀ ∈ Q.")))

;;   The set F of final or accepting states. F is an array of the same size as Q
;; with the accepting states under the same respective indices as under Q.
(defclass F ()
  ((F :initarg :F
      :initform (make-state-vector 1)
      :reader F
      :documentation "A set of states F distinguished as accepting (or final) states F ⊆ Q.")))

(defclass FA (Q Σ Δ q₀ F)
  ((dsn :initarg dsn
	:initform (make-instance 'state-names)
	:reader dsn
	:documentation "_D_efault _S_tate _N_ames."))
  (:documentation "An finite automata is represented formally by a 5-tuple, (Q, Σ, Δ, q0, F)."))

;; https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton
(defclass NFA (FA) ()
  (:documentation "Nondeterministic Finite Automata."))


;;; Generic Function Prototypes
(defgeneric make-state-vector (size &key &allow-other-keys)
  (:documentation "Return the default chosen array type for states."))

(defgeneric make-state-name (state-names)
  (:documentation "Name a new state from a reference class instance for a series of states."))

(defgeneric make-Δ (Σ-type)
  (:documentation "Create respective character-transition map data-structure."))

(defgeneric push-state (state finite-automaton &key &allow-other-keys)
  (:documentation "Push a state into the finite automaton."))

(defgeneric push-transit (state-A state-B transit-char FA &key &allow-other-keys)
  (:documentation "Push a single transition on transit-char from state-A to state-B in FA."))

(defgeneric delete-transit (state-A state-B transit-char FA &key &allow-other-keys)
  (:documentation "Remove a transition on transit-char from state-A to state-B in FA."))

(defgeneric get-transit (state transit-char FA &key &allow-other-keys)
  (:documentation "Get list of states to transition to on transition character."))

(defgeneric push-fragment (fragment-type FA &key &allow-other-keys)
  (:documentation "Push new finite state automaton fragment onto FA by type."))


;;; Method Definitions
;;   By default the first state name generated by the name-preface.
(defmethod initialize-instance :after ((FA-instance FA) &key &allow-other-keys)
  (push-state 'next FA-instance :start-p t))

(defmethod make-state-vector ((size integer) &key
					       (initial-element nil)
					       (adjustable t)
					       (fill-pointer 0)
			      &allow-other-keys)
  (make-array size
	      :initial-element initial-element
	      :adjustable adjustable
	      :fill-pointer fill-pointer))

;;   The transitions are a hashtable that associates the literal next state
;; object with a character.
(defmethod make-Δ ((Σ-type (eql 'cl-utf)))
  (make-hash-table :test 'eql)) ;eql for cl char's

;;   To initialize a state, we name the state using the name-preface
;; and the iterate.
(defmethod make-state-name ((state-names-instance state-names))
  (with-slots (preface iterate) state-names-instance
    (format nil "~a~d" preface (1- (incf iterate)))))

(defmethod push-state ((next (eql 'next))
		       (FA-instance FA)
		       &key
			 (start-p nil)
			 (final-p nil)
		       &allow-other-keys)
  (push-state (make-state-name (dsn FA-instance))
	      FA-instance
	      :start-p start-p
	      :final-p final-p))

(defmethod push-state ((state integer)
		       (FA-instance FA)
		       &key
			 (start-p nil)
			 (final-p nil)
		       &allow-other-keys)
  (with-slots (Q) FA-instance
    (values FA-instance (when (<= state (fill-pointer Q))
			  state))))

			  
;; All the :before methods I use to organize the assigns for the single push-state operation.

(defmethod push-state :before ((state-name string)
			       (Q-instance Q)
			       &key
			       &allow-other-keys)
  (with-slots (Q) Q-instance
    (vector-push-extend state-name Q))) ; Push our state-name onto our vector of state names.

(defmethod push-state :before ((state-name string)
			       (Δ-instance Δ)
			       &key
			       &allow-other-keys)
  (with-slots (Σ Δ) Δ-instance
    (vector-push-extend (make-Δ Σ) Δ))) ; Extend Δ for state-name.

(defmethod push-state :before ((state-name string)
			       (q₀-instance q₀)
			       &key
				 (start-p nil)
			       &allow-other-keys)
  (with-slots (q₀) q₀-instance
    (when start-p
      (setf q₀ state-name)))) ; If start state then set as start state.

(defmethod push-state :before ((state-name string)
			       (F-instance F)
			       &key
				 (final-p nil)
			       &allow-other-keys)
  (with-slots (F) F-instance
    (if final-p
	(vector-push-extend state-name F) ;   Either it is a final state
	(vector-push-extend nil F))))     ; or it is not - so empty space pushed.

(defmethod push-state ((state-name string)
		       (FA-instance FA)
		       &key
		       &allow-other-keys)
  (with-slots (Q Δ F) FA-instance
    (values FA-instance                    ; Return mutated FA after all said and done...
	    (1- (and (fill-pointer Q)
		     (fill-pointer Δ)      ; (and quick consistency check)
		     (fill-pointer F)))))) ; ...as well as the state number.

;;; I don't like how the work for push-transit is organized...
(defmethod push-transit :before ((state-A integer)
				 (state-B integer)
				 (transit-char character)
				 (Δ-instance Δ)
				 &key &allow-other-keys)
  (with-slots (Δ) Δ-instance
    (let ((Δ.state-A (aref Δ state-A)))
      (push state-B (gethash transit-char Δ.state-A nil)))))

(defmethod push-transit :before ((state-A integer)
				 (state-B integer)
				 (ε (eql 'ε))
				 (NFA-instance NFA)
				 &key &allow-other-keys)
  (with-slots (Δ) NFA-instance
    (let ((Δ.state-A (aref Δ state-A)))
      (push state-B (gethash ε Δ.state-A nil)))))

(defmethod push-transit (state-A
			 state-B
			 transit-char
			 (FA-instance FA)
			 &key &allow-other-keys)
  FA-instance)

;; experimenting with symbol naming and readability...
(defmethod delete-transit :before ((state-A integer)
				   (state-B integer)
				   transit-char
				   (Δ-instance Δ)
				   &key &allow-other-keys)
  (with-slots (Δ) Δ-instance
    (let* ((Δ.state-A (aref Δ state-A))
           (Δ.state-A.transit-char.states (gethash transit-char Δ.state-A)))
      (if Δ.state-A.transit-char.states
	(let ((Δ.state-A.transit-char.states-no-B (delete state-B Δ.state-A.transit-char.states)))
	  (if Δ.state-A.transit-char.states-no-B
	      (setf (gethash transit-char Δ.state-A) Δ.state-A.transit-char.states-no-B)
	      (remhash transit-char Δ.state-A)))
	(remhash transit-char Δ.state-A)))))

(defmethod delete-transit (state-A
			   state-B
			   transit-char
			   (FA-instance FA)
			   &key &allow-other-keys)
  FA-instance)

(defmethod get-transit ((state integer)
			transit-char
			(Δ-instance Δ)
			&key &allow-other-keys)
  (with-slots (Δ) Δ-instance
    (let* ((Δ.state (aref Δ state))
	   (Δ.state.transit-char.states (gethash transit-char Δ.state)))
      Δ.state.transit-char.states)))


;;;   This recursive generic function is my initial way of organizing the problem and will probably
;;; run into space constraints in short order. Also, the goal was to make this not write-only code
;;; so that I could read this at some arbitrary future date.
 
;; begin*[ε]-->A-in A-out[ε]-->begin*
;;
;; begin-state[transit-char]-->end-state
;; 'regex-literal '((state-begin state-end) (char-1 char-2 ... char-n)) NFA
;; ==> NFA state-begin state-end
(defmethod push-fragment-2 ((fragment-type (eql 'regex-literal))
			    (argument-list list)
			    (NFA-instance NFA)
			    &key &allow-other-keys)
  (let* ((begin-end-list (first argument-list))
	 (state-begin (first begin-end-list))
	 (state-end (second begin-end-list))
	 (transit-char-list (second argument-list)))
    (multiple-value-bind (NFA-instance state-begin)
	(push-state state-begin
		    NFA-instance)
      (multiple-value-bind (NFA-instance state-end)
	  (push-state state-end
	              NFA-instance)
	(values
	 (dolist (transit-char transit-char-list NFA-instance)
	   (setf NFA-instance (push-transit state-begin
					    state-end
					    transit-char
					    NFA-instance)))
	 state-begin
	 state-end)))))

;; begin-state[ε]-->end-state
;; 'regex-ε '((state-1-in state-1-out) (state-2-in state-2-out) ... (state-n-in state-n-out)) NFA
;; --> 'regex-literal '((state-1-in state-1-out) ('ε)) NFA ... 'regex-literal '((state-n-in state-n-out)) NFA
;; ==> NFA state-1-in state-n-out
(defmethod push-fragment-2 ((fragment-type (eql 'regex-ε))
			    (argument-list list)
			    (NFA-instance NFA)
			    &key &allow-other-keys)
  (let ((state-in-1 (caar argument-list))
	(state-out-n nil))
    (dolist (state-pairs argument-list)
      (multiple-value-bind (NFA-instance-m state-in-m state-out-m)
	  (push-fragment-2 'regex-literal (list state-pairs (list 'ε)) NFA-instance)
	(setf state-out-n state-out-m)
	(setf NFA-instance-n NFA-instance-m)))
    (values NFA-instance-n state-in-1 state-out-n))) 

;; begin[ε]-->A-in + A-out[ε]-->B-in + B-out[ε]-->end
;;
;; 'regex-concat '((state-begin state-end) (frag-1-in frag-2-out) ... (frag-n-in frag-n-out)) NFA
;; --> 'regex-ε '((state-begin frag-1-in) (frag-2-out frag-3-in) ... (frag-n-out state-end)) NFA
;; ==> NFA state-begin state-end
(defmethod push-fragment-2 ((fragment-type (eql 'regex-concat))
			    (argument-list list)
			    (NFA-instance NFA)
			    &key &allow-other-keys)
  (let ((state-begin (caar argument-list))
	(state-end (cadar argument-list))
	(frag-1st-in (caadr argument-list))
	(frags-to-concat (cdr argument-list)))
    (labels ((chain-pairs (old-list new-list)
	       (if (cdr old-list)
		   (chain-pairs (cdr old-list)
			        (append new-list
					(list (list (cadar old-list) (caadr old-list)))))
		   (values (cadar old-list) new-list))))
      (multiple-value-bind (frag-nth-out chain-pairs)
	  (chain-pairs frags-to-concat (list))
	(push-fragment-2 'regex-ε
			 (append (list (list state-begin frag-1st-in))
			         chain-pairs
			         (list (list frag-nth-out state-end)))
			 NFA-instance)))))

;; begin[ε] -->A-in A-out[ε]--> ||t
;;    ||    -->B-in B-out[ε]--> end
;;
;; 'regex-or '((state-begin state-end) (frag-1-in frag-1-out) ... (frag-n-in frag-n-out)) NFA
;; --> 'regex-ε '((state-begin frag-1-in) ... (state-begin frag-n-in) (frag-1-out state-end) ... (frag-n-out state-end)) NFA
;; ==> NFA state-begin state-end
(defmethod push-fragment-2 ((fragment-type (eql 'regex-or))
			    (argument-list list)
			    (NFA-instance NFA)
			    &key &allow-other-keys)
  (let ((state-begin (caar argument-list))
	(state-end (cadar argument-list))
	(frags-to-or (cdr argument-list))
	(or-pairs (list)))
    (push-fragment-2 'regex-ε
		     (dolist (state-pairs frags-to-or or-pairs)
		       (setf or-pairs (append or-pairs
					      (list (list state-begin (car state-pairs)))
					      (list (list (cadr state-pairs) state-end)))))
		     NFA-instance)))

;; begin*[ε]-->A-in A-out[ε]-->begin*
;; 
;; 'regex-star '((state-begin state-end) (frag-in frag-out)) NFA
;; --> 'regex-ε '((state-begin state-end) (state-end state-begin) (state-begin frag-in) (frag-out state-end)) NFA
;; ==> NFA state-begin state-end
(defmethod push-fragment-2 ((fragment-type (eql 'regex-star))
			    (argument-list list)
			    (NFA-instance NFA)
			    &key
			    &allow-other-keys)
  (let ((state-begin (caar argument-list))
	(state-end (cadar argument-list))
	(frag-in (caadr argument-list))
	(frag-out (caddr argument-list)))
    (push-fragment-2 'regex-ε
		     (list (list state-begin state-end)
			   (list state-end state-begin)
			   (list state-begin frag-in)
			   (list frag-out state-end))
		     NFA-instance)))

;; 'regex-plus '((state-begin state-end) (frag-in frag-out)) NFA
;; --> 'regex-opt '((state-begin state-end) (frag-in frag-out)) NFA
;; ==> NFA state-begin state-end
(defmethod push-fragment-2 ((fragment-type (eql 'regex-plus))
			    (argument-list list)
			    (NFA-instance NFA)
			    &key
			    &allow-other-keys)
  (push-fragment-2 'regex-opt argument-list NFA-instance)) 

;; 'regex-interval '((state-begin state-end) (interval-1-char-start interval-1-char-end) ...
;;    ... (interval-n-char-start interval-n-char-end) NFA
;; --> 'regex-literal '((state-begin state-end) (interval-1-char-start interval-1-char-2 ... interval-1-char-end ... interval-n-char-start interval-n-char-2 ... interval-n-char-end)) NFA
;; ==> NFA state-begin state-end
(defmethod push-fragment-2 ((fragment-type (eql 'regex-interval))
			    (argument-list list)
			    (NFA-instance NFA)
			    &key
			    &allow-other-keys)
  nil)

;; 'regex-optional '((state-begin state-end) (frag-in frag-out)) NFA
;; --> 'regex-ε '((state-begin state-end) (state-begin frag-in) (frag-out state-end)) NFA
;; ==> NFA state-begin state-end
(defmethod push-fragment-2 ((fragment-type (eql 'regex-optional))
			    (argument-list list)
			    (NFA-instance NFA)
			    &key
			    &allow-other-keys)
  (let ((state-begin (caar argument-list))
	(state-end (cadar argument-list))
	(frag-in (caadr argument-list))
	(frag-out (caddr argument-list)))
    (push-fragment-2 'regex-ε
		     (list (list state-begin state-end)
			   (list state-begin frag-in)
			   (list frag-out state-end))
		     NFA-instance)))
